var furver = (function () {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function promise() {
    let _resolve;
    let _reject;
    const promise = new Promise((resolve, reject) => {
      _resolve = resolve;
      _reject = reject;
    });
    promise.resolve = _resolve;
    promise.reject = _reject;
    return promise;
  }
  function promises() {
    let promises = [];
    return {
      promise() {
        const p = promise();
        promises.push(p);
        return p;
      },
      resolve(x) {
        promises.forEach(p => p.resolve(x));
        promises = [];
        return x;
      },
      reject(x) {
        promises.forEach(p => p.reject(x));
        promises = [];
        return x;
      }
    };
  }

  function debounce(callback, milliseconds) {
    const {
      resolve,
      reject,
      promise
    } = promises();
    let timeout;
    innerDebounce.calls = [];
    async function innerDebounce() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerDebounce.calls.push(args);
      timeout && clearTimeout(timeout);
      timeout = setTimeout(() => {
        resolve(callback(innerDebounce.calls));
        innerDebounce.calls = [];
      }, milliseconds);
      return promise();
    }
    innerDebounce.reject = reject;

    // TODO: Consider adding a resolve for an early resolve.

    return innerDebounce;
  }
  function debounceWithIndex(callback, milliseconds) {
    const innerDebounce = debounce(callback, milliseconds);
    return async function () {
      const index = innerDebounce.calls.length;
      return (await innerDebounce(...arguments))[index];
    };
  }

  class FurverError extends Error {}
  class FurverInvalidSchemaError extends FurverError {}

  // const debug = _debug.extend('client')
  // const debugError = debug.extend('error')
  // const debugFetch = debug.extend('fetch')

  FurverClient.bulkPost = function () {
    return debounceWithIndex(async calls => {
      const [[url, options]] = calls;
      const body = JSON.stringify([calls.map(_ref => {
        let [, {
          body
        }] = _ref;
        return body;
      })]);
      const _options = _objectSpread2(_objectSpread2({}, options), {}, {
        method: 'post',
        body
      });

      // debugFetch(url, _options)

      const res = await fetch(url, _options);
      if (!res.ok) {
        // debugError(res)
        throw res;
      }
      const json = await res.json();

      // debug('Response', json)

      return json;
    }, 0);
  };

  // TBD: Should keep support for get requests. Implement a get fetch.
  // function furverGet (url, options) {
  //   debug('using get option')
  //   const { body, ...otherOptions } = options || {}
  //   const queryString = new URLSearchParams({ body }).toString()
  //   const fullUrl = `${url}?${queryString}`
  //
  //   return fetch(fullUrl, {
  //     method: 'get',
  //     ...otherOptions
  //   })
  // }

  FurverClient.schema = async function furverClientSchema(url) {
    // debug(`fetching schema from ${url}`)
    const schemaRes = await fetch(url);
    return await schemaRes.json();
  };
  const isFunction = x => typeof x === 'function';
  const castFunction = x => isFunction(x) ? x : () => x;
  async function FurverClient(_ref2) {
    let {
      endpoint = 'http://localhost:3000',
      fetch = FurverClient.bulkPost(),
      schema = FurverClient.schema
    } = _ref2;
    const api = {};
    const assignMethods = schema => {
      if (!Array.isArray(schema)) {
        throw new FurverInvalidSchemaError('Not a valid schema');
      }
      api.schema = () => schema;
      return schema.reduce((api, _ref3) => {
        let [name] = _ref3;
        // Ignore the call name.
        if (name === 'call') return api;
        api[name] = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return fetch(endpoint, {
            body: [name, ...args],
            method: 'post'
          });
        };
        api[name].toJSON = () => name;
        return api;
      }, api);
    };
    api.call = body => fetch(endpoint, {
      body,
      method: 'post'
    });

    // debug('FurverClient initialized with endpoint', endpoint)

    return assignMethods(await castFunction(schema)(endpoint === '/' ? '/schema' : "".concat(endpoint, "/schema")));
  }

  return FurverClient;

})();
