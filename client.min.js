var furver = (function (exports) {
  'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function promise() {
    let _resolve;
    let _reject;
    const promise = new Promise((resolve, reject) => {
      _resolve = resolve;
      _reject = reject;
    });
    promise.resolve = _resolve;
    promise.reject = _reject;
    return promise;
  }
  function promises() {
    let promises = [];
    return {
      promise() {
        const p = promise();
        promises.push(p);
        return p;
      },
      resolve(x) {
        promises.forEach(p => p.resolve(x));
        promises = [];
        return x;
      },
      reject(x) {
        promises.forEach(p => p.reject(x));
        promises = [];
        return x;
      }
    };
  }

  function debounce(callback) {
    let milliseconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const {
      resolve,
      reject,
      promise
    } = promises();
    let timeout;
    innerDebounce.calls = [];
    async function innerDebounce() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerDebounce.calls.push(args);
      timeout && clearTimeout(timeout);
      timeout = setTimeout(() => {
        resolve(callback(innerDebounce.calls));
        innerDebounce.calls = [];
      }, milliseconds);
      return promise();
    }
    innerDebounce.reject = reject;

    // TODO: Consider adding a resolve for an early resolve.

    return innerDebounce;
  }
  function debounceWithIndex(callback) {
    let milliseconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    const innerDebounce = debounce(callback, milliseconds);
    return async function () {
      const index = innerDebounce.calls.length;
      return (await innerDebounce(...arguments))[index];
    };
  }

  class FurverError extends Error {}
  class FurverInvalidSchemaError extends FurverError {}

  const _excluded = ["body"];

  // const debug = _debug.extend('client')
  // const debugError = debug.extend('error')
  // const debugFetch = debug.extend('fetch')

  const bulk = fetchFn => debounceWithIndex(calls => {
    const [[url, options]] = calls;
    const body = JSON.stringify([calls.map(_ref => {
      let [, {
        body
      }] = _ref;
      return body;
    })]);
    return fetchFn(url, _objectSpread2(_objectSpread2({}, options), {}, {
      body
    }));
  });
  const post = bulk(async (url, options) => {
    const res = await fetch(url, options);
    if (!res.ok) {
      throw res;
    }
    const json = await res.json();
    return json;
  });
  const get = bulk(async (url, argOptions) => {
    const _ref2 = argOptions || {},
      {
        body
      } = _ref2,
      options = _objectWithoutProperties(_ref2, _excluded);
    const queryString = new URLSearchParams({
      body
    }).toString();
    const fullUrl = "".concat(url, "?").concat(queryString);
    const res = await fetch(fullUrl, options);
    if (!res.ok) {
      throw res;
    }
    const json = await res.json();
    return json;
  });
  client.schema = async function furverClientSchema(url) {
    // debug(`fetching schema from ${url}`)
    const schemaRes = await fetch(url);
    return await schemaRes.json();
  };
  const isFunction = x => typeof x === 'function';
  const castFunction = x => isFunction(x) ? x : () => x;
  async function client(_ref3) {
    let {
      endpoint = 'http://localhost:3000',
      fetch = post,
      schema = client.schema
    } = _ref3;
    const api = {};
    const assignMethods = schema => {
      if (!Array.isArray(schema)) {
        throw new FurverInvalidSchemaError('Not a valid schema');
      }
      api.schema = () => schema;
      return schema.reduce((api, _ref4) => {
        let [name] = _ref4;
        // Ignore the call name.
        if (name === 'call') return api;
        api[name] = function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return fetch(endpoint, {
            body: [name, ...args],
            method: 'post'
          });
        };
        api[name].toJSON = () => name;
        return api;
      }, api);
    };
    api.call = body => fetch(endpoint, {
      body,
      method: 'post'
    });

    // debug('client initialized with endpoint', endpoint)

    return assignMethods(await castFunction(schema)(endpoint === '/' ? '/schema' : "".concat(endpoint, "/schema")));
  }

  exports.bulk = bulk;
  exports.client = client;
  exports.default = client;
  exports.get = get;
  exports.post = post;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
